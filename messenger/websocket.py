import sys
import pika
import uwsgi

def application(env, start_response):
	connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))

	channel = connection.channel()

	exchange = env['PATH_INFO'].replace('/', '')

	print(exchange)

	channel.exchange_declare(exchange=exchange, exchange_type='fanout')


	# exclusive means the queue should be deleted once the connection is closed 

	result = channel.queue_declare(queue='', exclusive=True)

	# random queue name generated by RabbitMQ
	queue_name = result.method.queue  

	channel.queue_bind(exchange=exchange, queue=queue_name)

	uwsgi.websocket_handshake(env['HTTP_SEC_WEBSOCKET_KEY'],
	        env.get('HTTP_ORIGIN', ''))

	def keepalive():
		#call websocket connection every 25sec and keep it alive
		try:
			uwsgi.websocket_recv_nb()
			connection.add_timeout(25,keepalive)
		except OSError as error:
			connection.close()
			print(error)
	    	#Kill porcesses and force uwsgi to refresh
			sys.exit(1)
			keepalive()

	while True:
	    for method_frame, _, body in channel.consume(queue_name):
	        try:
	            uwsgi.websocket_send(body)
	        except OSError as error:
	            print(error)
	            #Kill porcesses and force uwsgi to refresh
	            sys.exit(1)
	        else:
	        	# acknowledge message             
	        	channel.basic_ack(method_frame.delivery_tag)